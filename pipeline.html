<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pandas-Centric Data Processing Pipeline</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            background: #ffffff;
            color: #1f2937;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .header {
            text-align: center;
            margin-bottom: 3rem;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .header h1 {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
        }
        
        .header p {
            font-size: 1.2rem;
            opacity: 0.8;
            color: #6b7280;
        }
        
        .section {
            background: #f9fafb;
            border: 1px solid #d1d5db;
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .section:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(59, 130, 246, 0.1);
        }
        
        .section h2 {
            color: #3b82f6;
            font-size: 1.8rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .section h3 {
            color: #60a5fa;
            font-size: 1.4rem;
            margin: 1.5rem 0 0.8rem 0;
            border-bottom: 2px solid rgba(96, 165, 250, 0.3);
            padding-bottom: 0.3rem;
        }
        
        .icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border-radius: 6px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #0f172a;
            font-size: 0.8rem;
        }
        
        .code-block {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
            position: relative;
            color: #374151;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .code-block::before {
            content: 'pandas';
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            color: #3b82f6;
            font-size: 0.7rem;
            background: rgba(59, 130, 246, 0.1);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }
        
        .highlight {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(29, 78, 216, 0.1));
            border-left: 4px solid #3b82f6;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }
        
        .pandas-pattern {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.1));
            border-left: 4px solid #10b981;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .feature-card {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .feature-card:hover {
            border-color: #3b82f6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.1);
        }
        
        .feature-card h4 {
            color: #111827;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }
        
        .feature-card p {
            color: #6b7280;
            font-size: 0.9rem;
        }
        
        ul {
            color: #4b5563;
            margin-left: 1.5rem;
        }
        
        li {
            margin-bottom: 0.5rem;
        }
        
        .data-flow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }
        
        .flow-step {
            background: linear-gradient(135deg, #e5f3ff, #dbeafe);
            border: 1px solid #93c5fd;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            position: relative;
            min-width: 120px;
            text-align: center;
            color: #1e40af;
        }
        
        .flow-step:not(:last-child)::after {
            content: '‚Üí';
            position: absolute;
            right: -1.5rem;
            top: 50%;
            transform: translateY(-50%);
            color: #3b82f6;
            font-weight: bold;
        }
        
        .method-showcase {
            background: rgba(15, 23, 42, 0.9);
            border: 2px solid #334155;
            border-radius: 12px;
            padding: 2rem;
            margin: 2rem 0;
        }
        
        .method-box {
            display: inline-block;
            background: linear-gradient(135deg, #1e293b, #0f172a);
            border: 1px solid #475569;
            border-radius: 8px;
            padding: 0.8rem 1.2rem;
            margin: 0.3rem;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.3s ease;
            color: #3b82f6;
        }
        
        .method-box:hover {
            border-color: #3b82f6;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.2);
            transform: translateY(-2px);
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .data-flow {
                flex-direction: column;
            }
            
            .flow-step:not(:last-child)::after {
                content: '‚Üì';
                right: 50%;
                top: 100%;
                transform: translate(50%, 0.5rem);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Pandas-Centric Data Pipeline</h1>
            <p>A Deep Dive into DataFrame Operations and Data Transformation Patterns</p>
        </header>

        <div class="section">
            <h2><span class="icon">üêº</span>Core Pandas Architecture</h2>
            
            <p>This codebase is fundamentally a sophisticated pandas operation pipeline. Every function is designed around DataFrame transformations, with heavy use of pandas' time series capabilities, data alignment, and vectorized operations.</p>

            <div class="data-flow">
                <div class="flow-step">CSV Loading<br><code>pd.read_csv()</code></div>
                <div class="flow-step">Date Processing<br><code>pd.to_datetime()</code></div>
                <div class="flow-step">DataFrame Merging<br><code>.merge()</code></div>
                <div class="flow-step">Feature Engineering<br><code>.pipe()</code></div>
                <div class="flow-step">Index Operations<br><code>.set_index()</code></div>
            </div>

            <div class="pandas-pattern">
                <strong>Primary Pattern:</strong> The entire system is built around pandas DataFrames as the core data structure. Every operation maintains DataFrame integrity with proper indexing, column management, and data type optimization.
            </div>
        </div>

        <div class="section">
            <h2><span class="icon">üîó</span>Method Chaining and Functional Style</h2>
            
            <p>The codebase extensively uses pandas method chaining, creating clean, readable data transformation pipelines:</p>

            <div class="code-block">
# Classic pandas method chaining pattern
options = (
    pd.read_csv(csv_path, parse_dates=['t_date', 'expiration_date'])
    .pipe(filter_dates, 't_date', first_date, last_date)
    .pipe(add_mid)
    .pipe(add_spread)
)

# DataFrame operations with column standardization
features_df.columns = features_df.columns.str.lower()
features_df = features_df.loc[:, ~features_df.columns.duplicated()]
            </div>

            <div class="method-showcase">
                <h3>Pandas Methods Used Throughout:</h3>
                <div class="method-box">read_csv()</div>
                <div class="method-box">merge()</div>
                <div class="method-box">pipe()</div>
                <div class="method-box">set_index()</div>
                <div class="method-box">fillna()</div>
                <div class="method-box">drop_duplicates()</div>
                <div class="method-box">between()</div>
                <div class="method-box">dt.normalize()</div>
                <div class="method-box">shift()</div>
                <div class="method-box">diff()</div>
                <div class="method-box">groupby()</div>
                <div class="method-box">astype('category')</div>
            </div>
        </div>

        <div class="section">
            <h2><span class="icon">üìÖ</span>Time Series Operations</h2>
            
            <p>Heavy emphasis on pandas datetime functionality for financial time series processing:</p>

            <h3>Date Range Generation</h3>
            <div class="code-block">
# Business day frequency with holiday exclusion
date_index = pd.date_range(start=first_date, end=last_date, freq='B')
df = pd.DataFrame(index=date_index)
df = df[~df.index.isin(list_holidays)]
            </div>

            <h3>DateTime Parsing and Normalization</h3>
            <div class="code-block">
# Multiple datetime parsing strategies
pd.read_csv(path, parse_dates=['t_date', 'expiration_date'])
pd.to_datetime(features_df['date'])
dates.dt.normalize().tolist()  # Remove time components
            </div>

            <h3>Time-Based Calculations</h3>
            <div class="code-block">
# Calendar days calculation using datetime arithmetic
calendar_days = (end_dates - start_dates).dt.days
options['time_to_maturity'] = options['dte'] / 365.25
            </div>

            <div class="pandas-pattern">
                <strong>Time Series Pattern:</strong> The system treats all data as time-indexed, using pandas' datetime index capabilities for alignment, filtering, and time-based calculations. Business day logic is handled through pandas date_range with frequency parameters.
            </div>
        </div>

        <div class="section">
            <h2><span class="icon">üîÑ</span>DataFrame Merging and Alignment</h2>
            
            <p>Sophisticated use of pandas merge operations to combine multiple data sources with proper alignment:</p>

            <div class="code-block">
# Left joins to preserve main dataset structure
df = df.merge(options_unique[['date', underlying]], on='date', how='left')
df = df.merge(features_df, on='date', how='left')
options = options.merge(underlying_prices[['date', underlying]], on='date', how='left')

# Date-based merging with dividend data
df = df.merge(df_div[['date', div_col]], on='date', how='left')
            </div>

            <div class="grid">
                <div class="feature-card">
                    <h4>Merge Strategy</h4>
                    <p>Consistently uses left joins to preserve the main dataset's date range while adding supplementary data from other sources.</p>
                </div>
                <div class="feature-card">
                    <h4>Data Alignment</h4>
                    <p>All merges are date-based, ensuring proper temporal alignment between options data, underlying prices, and features.</p>
                </div>
                <div class="feature-card">
                    <h4>Missing Value Handling</h4>
                    <p>Strategic use of fillna(0) for dividends and other sparse data, with forward-fill for price data.</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2><span class="icon">‚ö°</span>Vectorized Operations</h2>
            
            <p>Extensive use of pandas vectorized operations for performance on large datasets:</p>

            <div class="code-block">
# Vectorized financial calculations
df['mid'] = df[['bid', 'ask']].mean(axis=1)
df['spread'] = (df['ask'] - df['bid']) / df['mid']
df[underlying + 'tr'] = df[underlying].diff(1) / df[underlying].shift(1)
options['money'] = options['strike'] / options[underlying]
            </div>

            <h3>Boolean Indexing and Filtering</h3>
            <div class="code-block">
# Complex boolean masks for data filtering
mask = date_col.between(first_date, last_date, inclusive='both')
filtered_df = df[mask]

# Regex-based filtering
indicator_data = data[data['Event'].str.contains(pattern, case=False, na=False, regex=True)]

# Holiday exclusion
df = df[~df.index.isin(list_holidays)]
            </div>

            <div class="pandas-pattern">
                <strong>Vectorization Pattern:</strong> All mathematical operations use pandas vectorized methods rather than loops. This includes financial calculations, boolean filtering, and string operations, ensuring optimal performance on large option datasets.
            </div>
        </div>

        <div class="section">
            <h2><span class="icon">üéØ</span>Data Type Optimization</h2>
            
            <p>Strategic use of pandas data types for memory efficiency and performance:</p>

            <div class="code-block">
# Memory optimization through categorical data
options['symbol'] = options['symbol'].astype('category')

# Column standardization
features_df.columns = features_df.columns.str.lower()

# Duplicate column removal
features_df = features_df.loc[:, ~features_df.columns.duplicated()]
            </div>

            <h3>Index Management</h3>
            <div class="code-block">
# Strategic index usage for time series operations
df.set_index('date', inplace=True)
df_holidays = pd.read_csv(path, index_col='date', parse_dates=True)
adj_budget = pd.Series([weekly_budget] * df.shape[0], index=df.index)
            </div>

            <div class="grid">
                <div class="feature-card">
                    <h4>Categorical Data</h4>
                    <p>Converting symbol columns to categorical reduces memory usage for large options datasets with repeated ticker symbols.</p>
                </div>
                <div class="feature-card">
                    <h4>DatetimeIndex</h4>
                    <p>Using pandas DatetimeIndex enables powerful time-based operations and alignment across datasets.</p>
                </div>
                <div class="feature-card">
                    <h4>Column Management</h4>
                    <p>Systematic column naming, lowercasing, and duplicate removal ensures consistent DataFrame structure.</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2><span class="icon">üèó</span>Advanced Pandas Patterns</h2>
            
            <h3>Custom Pipe Functions</h3>
            <p>The code implements pandas .pipe() methodology for custom transformations:</p>

            <div class="code-block">
def add_mid(df):
    """Custom pipe function for mid-price calculation"""
    df['mid'] = df[['bid', 'ask']].mean(axis=1)
    return df

def add_spread(df):
    """Custom pipe function for spread calculation"""
    df['spread'] = (df['ask'] - df['bid']) / df['mid']
    return df

# Usage in method chain
df = df.pipe(add_mid).pipe(add_spread)
            </div>

            <h3>GroupBy Operations</h3>
            <div class="code-block">
# Monthly grouping for expiration date processing
month_groups = defaultdict(list)
for ts in sorted_list:
    month_groups[(ts.year, ts.month)].append(ts)

# Extract third entry from each group (monthly expiration logic)
result = [group[2] for group in month_groups.values() if len(group) >= 3]
            </div>

            <h3>String Operations</h3>
            <div class="code-block">
# Pandas string methods for pattern matching
data[data['Event'].str.contains(pattern, case=False, na=False, regex=True)]
features_df.columns = features_df.columns.str.lower()
            </div>

            <div class="highlight">
                <strong>Advanced Pattern Recognition:</strong> The codebase demonstrates sophisticated pandas usage including custom pipe functions, regex-based filtering, categorical optimization, and complex time-based grouping operations. This goes well beyond basic DataFrame operations into advanced pandas methodology.
            </div>
        </div>

        <div class="section">
            <h2><span class="icon">üìä</span>Performance Considerations</h2>
            
            <p>The code shows awareness of pandas performance best practices:</p>

            <ul>
                <li><strong>Vectorized Operations:</strong> All calculations use pandas vectorized methods rather than iterative approaches</li>
                <li><strong>Memory Management:</strong> Strategic use of categorical data types and column deduplication</li>
                <li><strong>Index Utilization:</strong> Proper DatetimeIndex usage for time series operations</li>
                <li><strong>Method Chaining:</strong> Efficient pipeline operations that minimize intermediate DataFrame creation</li>
                <li><strong>Selective Loading:</strong> Uses parse_dates parameter during CSV loading for efficiency</li>
            </ul>

            <div class="code-block">
# Performance optimization examples
parse_dates=['t_date', 'expiration_date']           # Parse dates during load
options['symbol'].astype('category')                # Reduce string memory usage
df.loc[:, ~df.columns.duplicated()]                # Remove duplicate columns
date_col.between(first_date, last_date)             # Efficient range filtering
            </div>

            <div class="pandas-pattern">
                <strong>Performance Pattern:</strong> The entire system is designed around pandas' strengths - vectorized operations, efficient merging, and time series functionality. This suggests the authors understand pandas performance characteristics and have optimized accordingly.
            </div>
        </div>

        <div class="section">
            <h2><span class="icon">üîç</span>Data Quality and Validation</h2>
            
            <p>Pandas-based data validation and cleaning throughout:</p>

            <div class="code-block">
# Missing value handling strategies
features_df['date'] = pd.to_datetime(features_df['date'])
df[div_col] = df[div_col].fillna(0)
df[underlying + 'tr'] = df[underlying + 'tr'].fillna(0)
options[underlying] = options[underlying].fillna(0)

# Data validation
if not os.path.exists(path_to_file):
    raise FileNotFoundError(f"Copy the CSV {path_to_file} first.")
            </div>

            <p>The system handles common pandas data quality issues including missing values, data type conversions, and duplicate removal using pandas-native methods.</p>
        </div>
    </div>
</body>
</html>
