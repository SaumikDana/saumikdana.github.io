<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VaR Sweep Visualizer</title>
  <style>
    :root {
      --bg: #ffffff; /* white */
      --panel: #f8fafc; /* slate-50 */
      --text: #1e293b; /* slate-800 */
      --muted: #64748b; /* slate-500 */
      --accent: #2563eb; /* blue-600 */
      --accent-2: #dc2626; /* red-600 */
      --grid: #e2e8f0; /* slate-200 */
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 24px; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 600px at 20% -10%, #f1f5f9 0%, var(--bg) 60%); color: var(--text);
    }
    h1 { font-size: 20px; margin: 0 0 12px; letter-spacing: .3px; }
    .app { max-width: 1200px; margin: 0 auto; }
    .card { background: linear-gradient(180deg, #ffffff, #fefefe 70%, #ffffff); border: 1px solid #e2e8f0; border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.1); }
    .row { display: grid; grid-template-columns: 1.5fr .8fr; gap: 18px; align-items: start; }
    .controls { background: var(--panel); border: 1px solid #e2e8f0; border-radius: 14px; padding: 14px; }
    .controls .group { margin-bottom: 12px; }
    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    input[type="number"] { width: 100%; padding: 8px 10px; border-radius: 10px; border: 1px solid #cbd5e1; background: #ffffff; color: var(--text); }
    input[type="range"] { width: 100%; }
    .inline { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .stat { font-feature-settings: "tnum" on, "lnum" on; font-variant-numeric: tabular-nums; }
    .stat b { color: #0f172a; }
    button { appearance: none; border: 1px solid #e2e8f0; background: linear-gradient(180deg, #f8fafc, #f1f5f9); color: #1e293b; padding: 9px 12px; border-radius: 12px; cursor: pointer; }
    button:hover { filter: brightness(1.1); }
    canvas { width: 100%; height: 460px; border-radius: 12px; background: #ffffff; border: 1px solid #e2e8f0; display: block; }
    .legend { font-size: 12px; color: var(--muted); margin-top: 8px; }
    .legend span { display: inline-flex; align-items: center; gap: 6px; margin-right: 14px; }
    .chip { width: 12px; height: 12px; border-radius: 3px; display: inline-block; }
    .chip.blue { background: var(--accent); }
    .chip.red { background: var(--accent-2); }
    .footer { font-size: 12px; color: var(--muted); margin-top: 12px; }
    .kbd { background: #f8fafc; border: 1px solid #e2e8f0; padding: 2px 6px; border-radius: 6px; font-size: 11px; }

    /* Proof section styles */
    .container {
      max-width: 1200px;
      margin: 40px auto 0;
      padding: 20px;
      background: linear-gradient(180deg, #ffffff, #fefefe 70%, #ffffff);
      border: 1px solid #e2e8f0;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.1);
      color: var(--text);
    }
    .container h1 {
      font-size: 24px;
      margin-bottom: 20px;
      color: var(--accent);
      text-align: center;
    }
    .container h2 {
      font-size: 18px;
      margin: 20px 0 10px;
      color: var(--text);
      border-bottom: 1px solid #e2e8f0;
      padding-bottom: 8px;
    }
    .formula {
      background: var(--panel);
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      text-align: center;
      color: var(--accent);
    }
    .step {
      background: var(--panel);
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    .highlight {
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.1), rgba(37, 99, 235, 0.05));
      border-color: var(--accent);
    }
    .failure {
      background: linear-gradient(135deg, rgba(220, 38, 38, 0.1), rgba(220, 38, 38, 0.05));
      border-color: var(--accent-2);
    }
    .conclusion {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(34, 197, 94, 0.05));
      border-color: #22c55e;
    }
    .math {
      font-family: 'Courier New', monospace;
      color: var(--accent);
      background: rgba(37, 99, 235, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
    }
    .container ul {
      margin: 10px 0;
      padding-left: 20px;
    }
    .container li {
      margin-bottom: 5px;
    }
    .container strong {
      color: var(--text);
    }
    .container em {
      color: var(--accent-2);
    }
  </style>
</head>
<body>
  <div class="app card">
    <h1>VaR Sweep Visualizer — Return Distribution</h1>
    <div class="row">
      <div>
        <canvas id="plot" width="820" height="460"></canvas>
        <div class="legend">
          <span><i class="chip blue"></i> Return PDF (Normal)</span>
          <span><i class="chip red"></i> Left tail (area ≤ cutoff)</span>
        </div>
        <div class="footer">
          Tip: drag the slider or use <span class="kbd">←</span>/<span class="kbd">→</span> to sweep the vertical line. Click <em>Snap to 5%</em> to jump to the VaR<sub>95</sub> cutoff.
        </div>
      </div>
      <div class="controls">
        <div class="group inline">
          <div>
            <label>Mean return (μ)</label>
            <input id="mu" type="number" step="0.01" value="0" />
          </div>
          <div>
            <label>Std. dev. (σ, %)</label>
            <input id="sigmaPct" type="number" step="0.01" value="1" />
          </div>
        </div>
        <div class="group">
          <label>Sweep cutoff position (in σ units)</label>
          <input id="kSlider" type="range" min="-4" max="4" step="0.01" value="-1.64" />
          <div class="stat" id="kInfo"></div>
        </div>
        <div class="group">
          <button id="snap05">Snap to 5% (VaR<sub>95</sub>)</button>
        </div>
        <div class="group">
          <div class="stat" id="stats"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="container">
    <h1>Proof: Quantile Functions Are Not Convex</h1>

    <h2>Standard Convexity Test</h2>
    <p>For ANY function f to be convex, it must satisfy:</p>
    <div class="formula">
        f(λx + (1-λ)y) ≤ λf(x) + (1-λ)f(y)
    </div>
    <p>for all x, y in the domain and λ ∈ [0,1].</p>

    <h2>Applied to Quantiles</h2>
    <p>Here:</p>
    <ul>
        <li><span class="math">f = Q<sub>p</sub></span> (the quantile function)</li>
        <li><span class="math">x = X</span> (first distribution)</li>
        <li><span class="math">y = Y</span> (second distribution)</li>
        <li><span class="math">λx + (1-λ)y = Z</span> (the mixture distribution)</li>
    </ul>

    <p>So the test becomes:</p>
    <div class="formula">
        Q<sub>p</sub>(mixture) ≤ λQ<sub>p</sub>(X) + (1-λ)Q<sub>p</sub>(Y)
    </div>

    <h2>Finding Q<sub>0.6</sub>(X)</h2>
    <div class="step">
        <p>X is a degenerate distribution that always equals 2.</p>
        <p>For any probability level p, including p = 0.6:</p>
        <p class="math">Q<sub>0.6</sub>(X) = 2</p>
    </div>

    <h2>Finding Q<sub>0.6</sub>(Y)</h2>
    <div class="step">
        <p>Y is a degenerate distribution that always equals 10.</p>
        <p>For any probability level p, including p = 0.6:</p>
        <p class="math">Q<sub>0.6</sub>(Y) = 10</p>
    </div>

    <h2>What the Mixture Distribution Z Actually Is</h2>
    <div class="highlight">
        <p>The mixture Z = 0.3X + 0.7Y creates a discrete distribution:</p>
        <ul>
            <li>Takes value <strong>2</strong> with probability <strong>0.3</strong></li>
            <li>Takes value <strong>10</strong> with probability <strong>0.7</strong></li>
        </ul>
    </div>

    <h2>Finding Q<sub>0.6</sub>(Z) - The Key Step</h2>
    <div class="step">
        <p>To find the 60th percentile of Z:</p>
        <ul>
            <li>At value 2: cumulative probability = 0.3 < 0.6 ❌ (not enough)</li>
            <li>At value 10: cumulative probability = 1.0 ≥ 0.6 ✅ (sufficient)</li>
        </ul>
        <p>Therefore: <span class="math">Q<sub>0.6</sub>(Z) = 10</span></p>
    </div>

    <h2>Our Numbers</h2>
    <ul>
        <li>Left side: <span class="math">Q<sub>p</sub>(Z) = 10</span> (quantile jumps to 10)</li>
        <li>Right side: <span class="math">0.3(2) + 0.7(10) = 7.6</span> (smooth weighted average)</li>
        <li>Test: <span class="math">10 ≤ 7.6</span> ❌</li>
    </ul>

    <h2>Convexity Fails!</h2>
    <div class="failure">
        <p>The quantile function gives us 10 for the mixture, but convexity would require it to be ≤ 7.6. The quantile <strong>jumps discontinuously</strong> from 2 to 10, skipping over the weighted average of 7.6 entirely.</p>
        
        <p>Since <strong>10 > 7.6</strong>, the quantile function violates convexity.</p>
    </div>

    <div class="conclusion">
        <p>This discontinuous jump is exactly why VaR optimization is non-convex and computationally problematic. Standard optimization algorithms fail because the risk landscape has sudden jumps and multiple local optima.</p>
    </div>
  </div>

<script>
  // ----- Math helpers -----
  function erf(x) { // Abramowitz-Stegun approximation
    const sign = Math.sign(x); x = Math.abs(x);
    const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
    const t = 1/(1+p*x);
    const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
    return sign*y;
  }
  function pdf(x, mu, sigma){
    const z = (x-mu)/sigma;
    return Math.exp(-0.5*z*z)/(sigma*Math.sqrt(2*Math.PI));
  }
  function cdf(x, mu, sigma){
    return 0.5*(1+erf((x-mu)/(sigma*Math.SQRT2)));
  }
  function quantile(p, mu, sigma){ // inverse CDF via rational approximation (Acklam's method)
    // constants
    const a=[-3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02, 1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00];
    const b=[-5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02, 6.680131188771972e+01, -1.328068155288572e+01];
    const c=[-7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00, -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00];
    const d=[7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00, 3.754408661907416e+00];
    const plow=0.02425, phigh=1-plow; let q, r;
    if(p<plow){ q=Math.sqrt(-2*Math.log(p)); return mu + sigma*((( ((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5])/((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1); }
    if(p>phigh){ q=Math.sqrt(-2*Math.log(1-p)); return mu - sigma*((( ((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5])/((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1); }
    q=p-0.5; r=q*q; return mu + sigma*((((a[0]*r+a[1])*r+a[2])*r+a[3])*r+a[4])*q/((((b[0]*r+b[1])*r+b[2])*r+b[3])*r+b[4])*q+sigma*q*2.5066282746310002e+00*0; // minimal center formula
  }

  // ----- Plot setup -----
  const canvas = document.getElementById('plot');
  const ctx = canvas.getContext('2d');
  const muInput = document.getElementById('mu');
  const sigmaPctInput = document.getElementById('sigmaPct');
  const kSlider = document.getElementById('kSlider');
  const kInfo = document.getElementById('kInfo');
  const statsDiv = document.getElementById('stats');
  const snapBtn = document.getElementById('snap05');

  function px(v){ return Math.round(v); }
  function fmtPct(x){ return (x*100).toFixed(2) + '%'; }

  function draw(){
    const muPct = parseFloat(muInput.value||'0');
    const sigmaPct = Math.max(0.0001, parseFloat(sigmaPctInput.value||'1'));
    const mu = muPct/100; const sigma = sigmaPct/100;
    const k = parseFloat(kSlider.value); // in sigma units
    const xCut = mu + k*sigma; // cutoff return

    // domain and scaling
    const xmin = mu - 4*sigma, xmax = mu + 4*sigma;
    const w = canvas.width, h = canvas.height; const pad = 46; const plotW = w - 2*pad, plotH = h - 2*pad;
    ctx.clearRect(0,0,w,h);

    // grid
    ctx.save();
    ctx.translate(pad, pad);
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,plotW,plotH);
    ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1;
    for(let i=0;i<=8;i++){
      const gx = i/8*plotW; ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,plotH); ctx.stroke();
    }
    for(let i=0;i<=4;i++){
      const gy = i/4*plotH; ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(plotW,gy); ctx.stroke();
    }

    // scaling functions
    const xToPx = x => (x - xmin)/(xmax - xmin)*plotW;
    // y scale by pdf max at mu
    const yMax = pdf(mu, mu, sigma);
    const yToPx = y => plotH - (y/yMax)*plotH*0.95;

    // pdf curve
    ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2.2; ctx.beginPath();
    const N=600; for(let i=0;i<=N;i++){
      const x = xmin + (xmax - xmin)*i/N; const y = pdf(x, mu, sigma); const X = xToPx(x), Y = yToPx(y);
      if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
    }
    ctx.stroke();

    // shade left tail up to xCut
    const xCutClamped = Math.max(xmin, Math.min(xmax, xCut));
    ctx.fillStyle = 'rgba(220, 38, 38, 0.3)'; ctx.beginPath();
    ctx.moveTo(0, plotH);
    for(let i=0;i<=N;i++){
      const x = xmin + (xCutClamped - xmin)*i/N; const y = pdf(x, mu, sigma); const X=xToPx(x), Y=yToPx(y);
      if(i===0) ctx.lineTo(X, Y); else ctx.lineTo(X, Y);
    }
    ctx.lineTo(xToPx(xCutClamped), plotH); ctx.closePath(); ctx.fill();

    // cutoff line
    ctx.strokeStyle = '#dc2626'; ctx.setLineDash([6,6]); ctx.lineWidth = 2; ctx.beginPath();
    ctx.moveTo(xToPx(xCutClamped), 0); ctx.lineTo(xToPx(xCutClamped), plotH); ctx.stroke(); ctx.setLineDash([]);

    // axes labels
    ctx.fillStyle = '#64748b'; ctx.font = '12px ui-sans-serif, system-ui';
    // x ticks (percent)
    for(let i=-4;i<=4;i++){
      const x = mu + i*sigma; const X = xToPx(x); const label = ( (x)*100 ).toFixed(1)+'%';
      ctx.fillText(label, X-16, plotH+18);
      ctx.beginPath(); ctx.moveTo(X, plotH); ctx.lineTo(X, plotH+4); ctx.strokeStyle = '#64748b'; ctx.stroke();
    }
    ctx.fillText('Portfolio Return →', plotW-130, plotH+36);

    // stats
    const leftArea = cdf(xCut, mu, sigma);
    const var95 = -quantile(0.05, mu, sigma); // reported as positive loss
    kInfo.innerHTML = `<span class="stat">k = <b>${k.toFixed(2)}σ</b>  → cutoff return = <b>${(xCut*100).toFixed(2)}%</b></span>`;
    statsDiv.innerHTML = `
      <div class="stat">Left-tail probability at cutoff = <b>${(leftArea*100).toFixed(2)}%</b></div>
      <div class="stat">(Interpretation: ${((1-leftArea)*100).toFixed(2)}% chance of returns being worse than the cutoff)</div>
      <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 10px 0;">
      <div class="stat">VaR<sub>95</sub> (from distribution) = <b>${(var95*100).toFixed(2)}% loss</b>  
        <span style="color:#64748b">→ corresponds to cutoff at 5th percentile</span>
      </div>
    `;

    ctx.restore();
  }

  // interactions
  function snapTo05(){
    const sigma = Math.max(0.0001, parseFloat(sigmaPctInput.value||'1'))/100;
    // 5th percentile return = mu + z_0.05 * sigma, with z≈-1.64485362695147
    const z05 = -1.64485362695147;
    kSlider.value = z05.toFixed(2);
    draw();
  }

  kSlider.addEventListener('input', draw);
  muInput.addEventListener('input', draw);
  sigmaPctInput.addEventListener('input', draw);
  snapBtn.addEventListener('click', snapTo05);

  // keyboard nudge
  window.addEventListener('keydown', (e)=>{
    if(e.key==='ArrowLeft' || e.key==='ArrowRight'){
      const step = (e.shiftKey?0.1:0.01)*(e.key==='ArrowLeft'?-1:1);
      kSlider.value = (+kSlider.value + step).toFixed(2);
      draw();
    }
  });

  // init
  draw();
</script>

</body>
</html>
