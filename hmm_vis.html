<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Regime Detection</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #f5f3ff 0%, #dbeafe 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #7c3aed 0%, #4f46e5 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            gap: 10px;
            padding: 20px;
            background: #f9fafb;
            border-bottom: 2px solid #e5e7eb;
        }

        .tab {
            padding: 12px 24px;
            border: none;
            background: white;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            color: #6b7280;
            transition: all 0.3s;
        }

        .tab.active {
            background: #7c3aed;
            color: white;
            box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
        }

        .tab:hover:not(.active) {
            background: #f3f4f6;
        }

        .content {
            padding: 30px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .controls {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 25px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: #7c3aed;
            color: white;
            box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
        }

        .btn-primary:hover {
            background: #6d28d9;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-tertiary {
            background: #4f46e5;
            color: white;
        }

        .btn-tertiary:hover {
            background: #4338ca;
        }

        .time-display {
            text-align: right;
        }

        .time-label {
            font-size: 0.9em;
            color: #6b7280;
        }

        .time-value {
            font-size: 2em;
            font-weight: bold;
            color: #7c3aed;
        }

        .settings-row {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .setting {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .setting label {
            font-weight: 600;
            color: #374151;
        }

        select {
            padding: 8px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        select:focus {
            outline: none;
            border-color: #7c3aed;
        }

        input[type="range"] {
            width: 150px;
        }

        .chart-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 25px;
        }

        .chart-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 20px;
        }

        .chart-wrapper {
            position: relative;
            height: 350px;
        }

        .current-state {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .state-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }

        .state-card {
            padding: 20px;
            border-radius: 12px;
            border: 2px solid;
        }

        .state-card.observation {
            background: #faf5ff;
            border-color: #e9d5ff;
        }

        .state-card.detected {
            background: #eef2ff;
            border-color: #c7d2fe;
        }

        .card-label {
            font-size: 0.85em;
            color: #6b7280;
            margin-bottom: 8px;
        }

        .card-value {
            font-size: 2.5em;
            font-weight: bold;
        }

        .prob-bars {
            margin-top: 20px;
        }

        .prob-bar {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .prob-label {
            width: 80px;
            font-weight: 600;
            font-size: 0.95em;
        }

        .prob-track {
            flex: 1;
            height: 30px;
            background: #e5e7eb;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .prob-fill {
            height: 100%;
            border-radius: 15px;
            transition: width 0.3s ease;
        }

        .prob-value {
            width: 60px;
            text-align: right;
            font-weight: bold;
            font-size: 0.95em;
        }

        .param-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .param-card {
            background: linear-gradient(135deg, #faf5ff 0%, #eef2ff 100%);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid #e9d5ff;
        }

        .param-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .state-dot {
            width: 24px;
            height: 24px;
            border-radius: 50%;
        }

        .param-header h4 {
            font-size: 1.3em;
            color: #1f2937;
        }

        .param-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .param-label {
            color: #6b7280;
        }

        .param-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #7c3aed;
        }

        .info-box {
            background: #dbeafe;
            padding: 25px;
            border-radius: 15px;
            border: 2px solid #93c5fd;
        }

        .info-box h4 {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #1f2937;
        }

        .info-box p {
            color: #374151;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .matrix-box {
            background: white;
            padding: 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.9em;
            color: #4b5563;
        }

        .algo-step {
            border-left: 4px solid;
            padding: 20px;
            padding-left: 30px;
            border-radius: 0 12px 12px 0;
            margin-bottom: 25px;
        }

        .algo-step.step-1 {
            background: #faf5ff;
            border-color: #7c3aed;
        }

        .algo-step.step-2 {
            background: #eef2ff;
            border-color: #4f46e5;
        }

        .algo-step.step-3 {
            background: #dbeafe;
            border-color: #3b82f6;
        }

        .algo-step.step-4 {
            background: #d1fae5;
            border-color: #10b981;
        }

        .algo-step.step-5 {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .step-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .step-number {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.2em;
        }

        .step-1 .step-number { background: #7c3aed; }
        .step-2 .step-number { background: #4f46e5; }
        .step-3 .step-number { background: #3b82f6; }
        .step-4 .step-number { background: #10b981; }
        .step-5 .step-number { background: #f59e0b; }

        .formula {
            background: white;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            color: #4b5563;
            margin: 10px 0;
        }

        .key-insight {
            background: linear-gradient(135deg, #faf5ff 0%, #eef2ff 100%);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid #c7d2fe;
            margin-top: 30px;
        }

        .key-insight h4 {
            font-size: 1.2em;
            margin-bottom: 12px;
            color: #1f2937;
        }

        @media (max-width: 768px) {
            .state-grid {
                grid-template-columns: 1fr;
            }
            
            .control-row {
                flex-direction: column;
                gap: 15px;
            }
            
            .settings-row {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Interactive Regime Detection</h1>
            <p>Watch how HMM discovers hidden states in real-time</p>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('demo')">📊 Live Demo</button>
            <button class="tab" onclick="switchTab('params')">⚙️ Parameters</button>
            <button class="tab" onclick="switchTab('algorithm')">🔬 Algorithm</button>
        </div>

        <div class="content">
            <!-- Demo Tab -->
            <div id="demo" class="tab-content active">
                <div class="controls">
                    <div class="control-row">
                        <div class="button-group">
                            <button class="btn btn-primary" onclick="togglePlay()">
                                <span id="play-icon">▶️</span>
                                <span id="play-text">Play</span>
                            </button>
                            <button class="btn btn-secondary" onclick="reset()">
                                🔄 Reset
                            </button>
                            <button class="btn btn-tertiary" onclick="generateNewData()">
                                ⚙️ New Data
                            </button>
                        </div>
                        <div class="time-display">
                            <div class="time-label">Time Step</div>
                            <div class="time-value"><span id="current-step">1</span> / <span id="total-steps">50</span></div>
                        </div>
                    </div>
                    <div class="settings-row">
                        <div class="setting">
                            <label>States:</label>
                            <select id="num-states" onchange="updateSettings()">
                                <option value="2">2 States</option>
                                <option value="3">3 States</option>
                            </select>
                        </div>
                        <div class="setting">
                            <label>Data Points:</label>
                            <input type="range" id="data-length" min="20" max="100" value="50" oninput="updateDataLength()">
                            <span id="data-length-value" style="font-weight: bold; color: #7c3aed; min-width: 30px; display: inline-block;">50</span>
                        </div>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">Observations & Detected Regimes</div>
                    <div class="chart-wrapper">
                        <canvas id="main-chart"></canvas>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">State Probabilities Over Time</div>
                    <div class="chart-wrapper">
                        <canvas id="prob-chart"></canvas>
                    </div>
                </div>

                <div class="current-state" id="current-state-display" style="display: none;">
                    <div class="chart-title">Current Analysis (Time = <span id="analysis-time">1</span>)</div>
                    <div class="state-grid">
                        <div class="state-card observation">
                            <div class="card-label">Current Observation</div>
                            <div class="card-value" style="color: #7c3aed;" id="current-obs">0.00</div>
                        </div>
                        <div class="state-card detected">
                            <div class="card-label">Detected State</div>
                            <div class="card-value" id="current-state-name">LOW</div>
                        </div>
                    </div>
                    <div class="prob-bars" id="prob-bars"></div>
                </div>
            </div>

            <!-- Parameters Tab -->
            <div id="params" class="tab-content">
                <div class="chart-container">
                    <div class="chart-title">Learned Parameters</div>
                    <div class="param-grid" id="param-grid"></div>
                    <div class="info-box">
                        <h4>State Persistence</h4>
                        <p>States are "sticky" - the system tends to stay in the same state for multiple time periods. This is captured by high diagonal values in the transition matrix.</p>
                        <div class="matrix-box" id="transition-matrix"></div>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">Distribution Visualization</div>
                    <div class="chart-wrapper">
                        <canvas id="scatter-chart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Algorithm Tab -->
            <div id="algorithm" class="tab-content">
                <div class="chart-container">
                    <div class="chart-title">How The Algorithm Works</div>
                    
                    <div class="algo-step step-1">
                        <div class="step-header">
                            <div class="step-number">1</div>
                            <h3>Initialization</h3>
                        </div>
                        <p>Start with random guesses for state parameters (means, variances) and transition probabilities. Or use clustering to get better initial estimates.</p>
                    </div>

                    <div class="algo-step step-2">
                        <div class="step-header">
                            <div class="step-number">2</div>
                            <h3>E-Step (Expectation)</h3>
                        </div>
                        <p>Given current parameters, calculate the probability of being in each state at each time point.</p>
                        <div class="formula">γₜ(i) = P(Sₜ = i | O₁, O₂, ..., Oₜ)</div>
                    </div>

                    <div class="algo-step step-3">
                        <div class="step-header">
                            <div class="step-number">3</div>
                            <h3>M-Step (Maximization)</h3>
                        </div>
                        <p>Update parameters to maximize the likelihood of the observed data:</p>
                        <div class="formula">μᵢ = Σₜ γₜ(i) × Oₜ / Σₜ γₜ(i)</div>
                        <p style="margin-top: 10px; font-size: 0.9em; color: #6b7280;">(Weighted average of observations)</p>
                    </div>

                    <div class="algo-step step-4">
                        <div class="step-header">
                            <div class="step-number">4</div>
                            <h3>Forward Algorithm (Filtering)</h3>
                        </div>
                        <p><strong>Critical:</strong> At each time t, use ONLY observations up to time t (no look-ahead).</p>
                        <div class="formula">αₜ(i) = P(O₁, ..., Oₜ, Sₜ = i)</div>
                        <p style="margin-top: 10px; font-size: 0.9em; color: #6b7280;">Recursively computed: αₜ(j) = P(Oₜ|Sₜ=j) × Σᵢ αₜ₋₁(i) × aᵢⱼ</p>
                    </div>

                    <div class="algo-step step-5">
                        <div class="step-header">
                            <div class="step-number">5</div>
                            <h3>Convergence</h3>
                        </div>
                        <p>Repeat E-step and M-step until parameters stabilize (typically 50-100 iterations). The result: optimal state parameters and most likely state sequence.</p>
                    </div>

                    <div class="key-insight">
                        <h4>🔑 Key Insight</h4>
                        <p>The algorithm simultaneously learns the state parameters AND figures out which state you were in at each moment - all while using only past information for real-time applicability.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let state = {
            numStates: 2,
            dataLength: 50,
            observations: [],
            trueStates: [],
            detectedStates: [],
            stateProbabilities: [],
            learnedParams: null,
            currentStep: 0,
            isPlaying: false,
            playInterval: null
        };

        const stateColors = ['#f56565', '#48bb78', '#4299e1'];
        const stateNames2 = ['LOW', 'HIGH'];
        const stateNames3 = ['LOW', 'MEDIUM', 'HIGH'];

        let mainChart, probChart, scatterChart;

        // Initialize
        window.onload = function() {
            initCharts();
            generateNewData();
        };

        function initCharts() {
            // Main chart
            const mainCtx = document.getElementById('main-chart').getContext('2d');
            mainChart = new Chart(mainCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Observation',
                        data: [],
                        borderColor: '#7c3aed',
                        backgroundColor: 'rgba(124, 58, 237, 0.1)',
                        borderWidth: 3,
                        pointRadius: 4,
                        pointBackgroundColor: '#7c3aed',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        y: { beginAtZero: false }
                    }
                }
            });

            // Probability chart
            const probCtx = document.getElementById('prob-chart').getContext('2d');
            probChart = new Chart(probCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            max: 1,
                            ticks: {
                                callback: function(value) {
                                    return (value * 100).toFixed(0) + '%';
                                }
                            }
                        }
                    }
                }
            });

            // Scatter chart
            const scatterCtx = document.getElementById('scatter-chart').getContext('2d');
            scatterChart = new Chart(scatterCtx, {
                type: 'scatter',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: 'Time' }
                        },
                        y: { 
                            title: { display: true, text: 'Value' }
                        }
                    }
                }
            });
        }

        function generateNewData() {
            const stateMeans = state.numStates === 2 ? [3, 8] : [2, 5, 8];
            const stateStd = 0.3;
            const transitionProb = 0.05;
            
            state.observations = [];
            state.trueStates = [];
            let currentState = 0;
            
            for (let i = 0; i < state.dataLength; i++) {
                if (Math.random() < transitionProb) {
                    currentState = Math.floor(Math.random() * state.numStates);
                }
                
                const mean = stateMeans[currentState];
                const value = mean + (Math.random() - 0.5) * 2 * stateStd * 3;
                
                state.observations.push(value);
                state.trueStates.push(currentState);
            }
            
            runRegimeDetection();
            state.currentStep = 0;
            updateDisplay();
        }

        function runRegimeDetection() {
            const sorted = [...state.observations].sort((a, b) => a - b);
            const splitPoints = [];
            
            if (state.numStates === 2) {
                splitPoints.push((sorted[Math.floor(sorted.length / 2)] + sorted[Math.floor(sorted.length / 2) + 1]) / 2);
            } else {
                splitPoints.push((sorted[Math.floor(sorted.length / 3)] + sorted[Math.floor(sorted.length / 3) + 1]) / 2);
                splitPoints.push((sorted[Math.floor(2 * sorted.length / 3)] + sorted[Math.floor(2 * sorted.length / 3) + 1]) / 2);
            }
            
            const clusterMeans = [];
            for (let i = 0; i < state.numStates; i++) {
                const values = state.observations.filter(v => {
                    if (i === 0) return v <= splitPoints[0];
                    if (i === state.numStates - 1) return v > splitPoints[i - 1];
                    return v > splitPoints[i - 1] && v <= splitPoints[i];
                });
                clusterMeans.push(values.reduce((a, b) => a + b, 0) / values.length);
            }
            
            state.detectedStates = [];
            state.stateProbabilities = [];
            
            for (let t = 0; t < state.observations.length; t++) {
                const distances = clusterMeans.map(mean => Math.abs(state.observations[t] - mean));
                const recentState = t > 0 ? state.detectedStates[t - 1] : 0;
                
                const rawProbs = distances.map((d, i) => {
                    const similarity = Math.exp(-d * 2);
                    const persistence = i === recentState ? 2 : 1;
                    return similarity * persistence;
                });
                
                const sumProbs = rawProbs.reduce((a, b) => a + b, 0);
                const normalizedProbs = rawProbs.map(p => p / sumProbs);
                
                state.detectedStates.push(normalizedProbs.indexOf(Math.max(...normalizedProbs)));
                state.stateProbabilities.push(normalizedProbs);
            }
            
            state.learnedParams = {
                means: clusterMeans,
                splitPoints: splitPoints
            };
        }

        function updateDisplay() {
            document.getElementById('current-step').textContent = state.currentStep + 1;
            document.getElementById('total-steps').textContent = state.dataLength;
            
            // Update main chart
            const labels = [];
            const data = [];
            for (let i = 0; i <= state.currentStep; i++) {
                labels.push(i + 1);
                data.push(state.observations[i]);
            }
            
            mainChart.data.labels = labels;
            mainChart.data.datasets[0].data = data;
            mainChart.update('none');
            
            // Update probability chart
            const probDatasets = [];
            const stateNames = state.numStates === 2 ? stateNames2 : stateNames3;
            for (let i = 0; i < state.numStates; i++) {
                const probData = [];
                for (let t = 0; t <= state.currentStep; t++) {
                    probData.push(state.stateProbabilities[t][i]);
                }
                probDatasets.push({
                    label: `P(${stateNames[i]})`,
                    data: probData,
                    borderColor: stateColors[i],
                    backgroundColor: stateColors[i] + '20',
                    borderWidth: 3,
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            probChart.data.labels = labels;
            probChart.data.datasets = probDatasets;
            probChart.update('none');
            
            // Update current state display
            if (state.currentStep > 0) {
                document.getElementById('current-state-display').style.display = 'block';
                document.getElementById('analysis-time').textContent = state.currentStep + 1;
                document.getElementById('current-obs').textContent = state.observations[state.currentStep].toFixed(2);
                
                const detectedState = state.detectedStates[state.currentStep];
                const stateNames = state.numStates === 2 ? stateNames2 : stateNames3;
                document.getElementById('current-state-name').textContent = stateNames[detectedState];
                document.getElementById('current-state-name').style.color = stateColors[detectedState];
                
                // Update probability bars
                const probBarsHtml = state.stateProbabilities[state.currentStep].map((prob, i) => `
                    <div class="prob-bar">
                        <div class="prob-label" style="color: ${stateColors[i]}">${stateNames[i]}:</div>
                        <div class="prob-track">
                            <div class="prob-fill" style="width: ${prob * 100}%; background: ${stateColors[i]}"></div>
                        </div>
                        <div class="prob-value" style="color: ${stateColors[i]}">${(prob * 100).toFixed(1)}%</div>
                    </div>
                `).join('');
                document.getElementById('prob-bars').innerHTML = probBarsHtml;
            } else {
                document.getElementById('current-state-display').style.display = 'none';
            }
            
            // Update parameters tab
            updateParametersTab();
        }

        function updateParametersTab() {
            if (!state.learnedParams) return;
            
            const stateNames = state.numStates === 2 ? stateNames2 : stateNames3;
            const paramGridHtml = state.learnedParams.means.map((mean, i) => `
                <div class="param-card">
                    <div class="param-header">
                        <div class="state-dot" style="background: ${stateColors[i]}"></div>
                        <h4>State ${i + 1}: ${stateNames[i]}</h4>
                    </div>
                    <div class="param-row">
                        <span class="param-label">Mean (μ${i + 1}):</span>
                        <span class="param-value">${mean.toFixed(2)}</span>
                    </div>
                    <div class="param-row">
                        <span class="param-label">Std Dev (σ${i + 1}):</span>
                        <span class="param-value" style="color: #4f46e5">~0.30</span>
                    </div>
                </div>
            `).join('');
            document.getElementById('param-grid').innerHTML = paramGridHtml;
            
            // Update transition matrix
            let matrixHtml = 'Transition Matrix A (approximate):<br><br>';
            if (state.numStates === 2) {
                matrixHtml += 'HIGH → HIGH: 0.95   HIGH → LOW: 0.05<br>';
                matrixHtml += 'LOW → HIGH: 0.05   LOW → LOW: 0.95';
            } else {
                matrixHtml += 'LOW → LOW: 0.93   LOW → MED: 0.05   LOW → HIGH: 0.02<br>';
                matrixHtml += 'MED → LOW: 0.05   MED → MED: 0.90   MED → HIGH: 0.05<br>';
                matrixHtml += 'HIGH → LOW: 0.02   HIGH → MED: 0.05   HIGH → HIGH: 0.93';
            }
            document.getElementById('transition-matrix').innerHTML = matrixHtml;
            
            // Update scatter chart
            const datasets = [];
            for (let i = 0; i < state.numStates; i++) {
                const points = [];
                state.observations.forEach((obs, t) => {
                    if (state.detectedStates[t] === i) {
                        points.push({ x: t + 1, y: obs });
                    }
                });
                datasets.push({
                    label: stateNames[i],
                    data: points,
                    backgroundColor: stateColors[i],
                    pointRadius: 5,
                    pointHoverRadius: 7
                });
            }
            
            scatterChart.data.datasets = datasets;
            scatterChart.update();
        }

        function togglePlay() {
            state.isPlaying = !state.isPlaying;
            
            if (state.isPlaying) {
                document.getElementById('play-icon').textContent = '⏸️';
                document.getElementById('play-text').textContent = 'Pause';
                play();
            } else {
                document.getElementById('play-icon').textContent = '▶️';
                document.getElementById('play-text').textContent = 'Play';
                if (state.playInterval) {
                    clearTimeout(state.playInterval);
                }
            }
        }

        function play() {
            if (!state.isPlaying) return;
            
            if (state.currentStep < state.dataLength - 1) {
                state.currentStep++;
                updateDisplay();
                state.playInterval = setTimeout(play, 300);
            } else {
                state.isPlaying = false;
                document.getElementById('play-icon').textContent = '▶️';
                document.getElementById('play-text').textContent = 'Play';
            }
        }

        function reset() {
            state.currentStep = 0;
            state.isPlaying = false;
            document.getElementById('play-icon').textContent = '▶️';
            document.getElementById('play-text').textContent = 'Play';
            if (state.playInterval) {
                clearTimeout(state.playInterval);
            }
            updateDisplay();
        }

        function updateSettings() {
            state.numStates = parseInt(document.getElementById('num-states').value);
            generateNewData();
        }

        function updateDataLength() {
            const value = document.getElementById('data-length').value;
            document.getElementById('data-length-value').textContent = value;
            state.dataLength = parseInt(value);
            generateNewData();
        }

        function switchTab(tabName) {
            // Update tab buttons
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update tab content
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
            
            // Update scatter chart when switching to params tab
            if (tabName === 'params') {
                updateParametersTab();
            }
        }
    </script>
</body>
</html>